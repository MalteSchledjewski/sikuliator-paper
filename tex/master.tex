%Dokumentation: http://texdoc.net/
\documentclass[a4paper,twocolumn]{article}
\usepackage[a4paper]{geometry}

\usepackage[british]{babel}        
\usepackage[utf8]{inputenc}        % for umlauts and other non 7bit ascii things
\usepackage[T1]{fontenc}           % this is needed for correct output of umlauts in pdf
\usepackage{lmodern}               % use a vector based font, not a bitmap based font for T1
\usepackage[stretch=10]{microtype} % improves font placements
%\usepackage{graphicx}
\usepackage[breaklinks, colorlinks,draft=false
%, citecolor=black, filecolor=black, linkcolor=black, urlcolor=black ,pdfborder=0
]{hyperref}


\usepackage{listings}
\usepackage{color}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pseudostyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

% Define Language
\lstdefinelanguage{Pseudo}
{
	% list of keywords
	morekeywords={
		Click
	},
	sensitive=false, % keywords are not case-sensitive
	morecomment=[l]{//}, % l is for line comment
	morecomment=[s]{/*}{*/}, % s is for start and end delimiter
	morestring=[b]" % defines that strings are enclosed in double quotes
}


\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[autostyle=true,german=quotes]{csquotes}

\usepackage{graphicx}
%\usepackage{epstopdf}
%for plots: http://pgfplots.sourceforge.net/
%\usepackage[final]{pdfpages}

\usepackage{float}
\usepackage{rotating}

\usepackage[defernumbers=true,backend=biber,style=numeric]{biblatex}
\addbibresource{../bib/Sikuliator.bib}

\usepackage{todonotes}

\usepackage{placeins}

%\usepackage{chngcntr}
%\counterwithout{figure}{chapter}
%\counterwithout{table}{chapter}

%\usepackage{MnSymbol}
%\usepackage{listings}
%\lstset{tabsize=1,showtabs=false,extendedchars
%=false,escapebegin=\begin{text},escapeend=\end{text},literate=%
%    {Ö}{{\"O}}1
%    {Ä}{{\"A}}1
%    {Ü}{{\"U}}1
%    {ß}{{\ss}}1
%    {ü}{{\"u}}1
%    {ä}{{\"a}}1
%    {ö}{{\"o}}1
%    {~}{{\textasciitilde}}1,
%    %breakatwhitespace=true,
%    breaklines=true,
%    prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rhookswarrow}},
%    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rcurvearrowse}},
%    keepspaces=true,
%    }

%\usepackage{bigints}

\usepackage{enumitem}
\setlist{noitemsep}
%\theoremstyle{definition}
%\newtheorem{lemma}{Lemma}
%\newtheorem{definition}{Definition}
%\newtheorem*{note}{Bemerkung}
%\binoppenalty=\maxdimen
%\relpenalty=\maxdimen

\let\URL\url
\makeatletter
\def\url#1{\@URL#1;;\@nil}
\def\@URL#1;#2;#3\@nil{%
  \URL{#1}\ifx\relax#2\relax\else; \URL{#2}\fi}
\makeatother

\title{Sikuliator}
\author{Malte Schledjewski}
%\renewcommand{\baselinestretch}{1.1}
\linespread{1.1}

\hyphenation{Sikuliator OpenStack RESTHeart MongoDB SikuliX OpenCV Akka AkkaFSM PostgreSQL MariaDB VM VMs}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

%\setlength{\belowcaptionskip}{10pt}
%\setlength{\textfloatsep}{20.0pt plus 2.0pt minus 4.0pt}
%\setlength{\intextsep}{12.0pt plus 2.0pt minus 0.0pt}
%\setlength{\abovecaptionskip}{5pt}
%\setlength{\floatsep}{20.0pt plus 2.0pt minus 10.0pt}

\usepackage{parskip}
%\usepackage[compact]{titlesec}
\usepackage{emptypage}
\AtBeginDocument{\addtocontents{toc}{\protect\thispagestyle{empty}}} 


\newcommand{\VMC}[0]{VMC®}
\newcommand{\Sik}[0]{Sikuliator}

\newcommand{\notImplemented}[0]{\item[$\times$] }
\newcommand{\partiallyImplemented}[0]{\item[$\boxdot$] }
%\newcommand{\implemented}[0]{\item[$\blacksquare$] }
\newcommand{\implemented}[0]{\item[\checkmark] }

\begin{document}

%\pagestyle{headings}
%\pagestyle{myheadings}
%\markright{Malte Schledjewski\hfill Sikuliator\hfill}

%\setlength{\parskip}{2pt plus 0pt minus 0pt}

%\setlength{\parindent}{0cm}
\maketitle
\begin{abstract}
	
	
	This paper describes the development of \Sik{}, 
	a free system for automated GUI testing distributed across many machines.
	
\end{abstract}
\listoftodos

\tableofcontents

\section{Context}

The first version of \Sik{} is designed to suit the 
\emph{\VMC{} - Virtual Measurement Campaign}\cite{VMConline} developer team's needs in the
department \emph{Mathematical Methods in Dynamics and Durability} 
at the Fraunhofer Institute for Industrial Mathematics ITWM.
\VMC{} is an application based on clients and a central database.
The clients are written in C++ and use the Qt Framework.
For some part of the client an embedded browser based on Qt WebEngine is used.

GUI testing \VMC{} is a time consuming task for the team.
Tests are managed by TestLink~\cite{TestLink} but have to be executed manually inside virtual machines.
This is time consuming, especially because \VMC{} has many computations which last minutes or hours 
leaving the tester sitting idle while testing. 
Thorough testing is often done just prior to a release due to constrained resources.
This causes regressions to be spotted late in the development cycle and potentially delaying the release. 

The team could use for example the Qt~Test~framework\cite{QtTest} which enables simulating mouse and keyboard input for the Qt framework to automate at least some parts of the test.
%Qt Test Overview - http://doc.qt.io/qt-5/qtest-overview.html
It does allow for checks based on the internal structure but not for visual appearance.

For web interfaces there exist frameworks like Selenium\cite{Selenium} to automatically distribute GUI test execution across many browsers.
These frameworks use the DOM and not the visual appearance.

Testing a hybrid application like \VMC{}, consisting of some parts written in C++ and some running in an embedded browser, is not covered by any freely available tool the team could find.

A bachelor thesis\cite{BachelorMapViewer}, which is based on a part of \VMC{}, mentions SikuliX\cite{SikuliX}.
SikuliX is a framework for GUI testing and automation.
It uses a matching operation from OpenCV\cite{OpenCV} to search for elements based on reference images.
SikuliX also simulates keyboard and mouse input.
The bachelor thesis mentions the idea to use the provided Python API in combination with a unit testing framework.
After some more discussions it was decided that this would require too much knowledge of Python to write tests.

\section{Goals}
The overarching goal of this project is to build Sikuliator, a system to distribute automatic GUI tests across many machines.
Instead of using Python to specify tests a new format will be developed.


The following goals were chosen in accordance with the \VMC{} development team.
Not all of them will be included in the first version.
\begin{enumerate}
	\item A free system under a free license shall be build.
	\item GUI tests are automatically executed without manual intervention.
	\item Tests may be executed in parallel across many machines.
	\item Tests must be reproducible.
	\item Simple tests must be easy to define without much programming knowledge.
	\item The success of a test execution may be rated automatically or manually by inspecting a created screenshot.
	\item Results are aggregated and statistics, trends and reports created.
	\item No client needs to be installed to create tests.
\end{enumerate}


%A tool which could execute a given sequence of steps and let the tester decide the correctness afterwards would increase the testers throughput.

The main challenges are believed to be:
\begin{enumerate}
	\item Creating the description format to be easy but powerful enough.
	\item Managing tests for different versions of the software.
	\item Ensuring reproducibility while not wasting too much time and too many resources.
	\item Handling external state like the database used in \VMC{}.
\end{enumerate}


\section{Ideas and Features}
\paragraph{Legend}
\begin{itemize}
	\implemented implemented in the first version
	\partiallyImplemented partially implemented in the first version
	\notImplemented not implemented in the first version
\end{itemize}
	
	In the following VM stands for virtual machine.
\begin{itemize}
	\implemented GUI tests are automatically executed.
	\implemented Test can be executed in parallel across many machines.
	\partiallyImplemented The success of a test execution can be
	\begin{itemize}
		\implemented rated automatically,
		\notImplemented manually by comparing created screenshots to reference images.
	\end{itemize}
	\implemented No client needed to manage the tests.
	\implemented Test results are aggregated.
	\partiallyImplemented Statistics are gathered.
	\begin{itemize}
		\implemented Track execution time.
	\end{itemize}
	\notImplemented Reports can be generated as PDFs.
	\notImplemented Notify about major changes in execution time.
	\implemented Run tests inside VMs to have a controlled environment.
	\notImplemented Use VM snapshots to remove redundant execution of common test beginnings.
	\notImplemented Authentication and authorization.
	\partiallyImplemented Web interface
	\notImplemented Keep an audible log.
	\notImplemented Collect coverage data and select relevant tests to execute based on change set.
	\notImplemented Use SikuliX's region support instead of searching across the whole screen.
	\notImplemented Use a monitoring system to check for crashed clients.
	\notImplemented Dynamically spin up VM instances as needed.
	\notImplemented Have an interactive mode for test creation where one client directly executes steps.
	\notImplemented Integrate \Sik{} into the Jenkins\cite{Jenkins} pipeline as a step after building the software.
\end{itemize}

\Sik{}'s first version is developed as a graded project by Malte Schledjewski.
The available time is limited and therefore the first version's scope is reduced.
It will be more of a proof of concept.
Some parts like snapshots do not have a high priority because \VMC{} has external state in the database which is not captured. 
Also no coverage data is already gathered so instrumenting the build would cost too much time. 
SikuliX's region support increases the complexity of describing tests and will therefore only be integrated in a later version.

Sikuliator will run in the intranet at the ITWM.
Also it will at first be used my a limited amount of testers.
Therefore no user or rights management will be necessary for the initial version.

Sikuliator will offer an API but no GUI or means to create reports at first.


%\section{System Overview}
%Currently virtual machines which reset to a specified snapshot on reboot are used for testing.
%A test client including SikuliX will be installed and integrated into a new snapshot.
%This client connects to the master node to ask for work.
%No messaging broker is used but communication happens over simple HTTP to keep the system administration simple.
%
%The virtual machines are managed by a system broker.
%It knows how to reset machines to a clean state and may do health checking.
%In the future there may be back ends based on VirtualBox\cite{VirtualBox}, OpenStack\cite{OpenStack} or the alike to dynamically spin up instances when needed.

%SikuliX is based on searching for reference images, therefore a lot of binary files have to be stored.
%They must also be accessible over HTTP for integration into the web interface.
%One idea was to use an object storage system like OpenStack~Swift\cite{OpenStackSwift} or Riak~S2\cite{RiakS2}.
%These systems need a lot of knowledge to configure and maintain.
%Support for them will maybe be added in the future.
%In the meantime a solution based on MongoDB's GridFS\cite{GridFS} and RESTHeart\cite{RESTHeart} is chosen.
%It provides rather simple set up contained on one machine.
%
%The test executables are also stored in RESTHeart so that no additional subsystem has to be integrated.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% add system overview graphic here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Test Specification}
There were two ideas for specifying tests: either use a structured text format like XML, JSON, YAML and the like or create a domain specific language (DSL).
Creating a DSL seemed to complex and time consuming for the first version.
Therefore a simple format based on XML is defined.

The future DSL will integrate snapshots and region support.
This needs careful language design.
Tools like JetBrains' Meta Programming System\cite{MPS}
or Eclipse Xtext\cite{Xtext} will probably be used to get some tooling support like syntax completion.
It will probably mirror natural language more closely, 
as in example \ref{lst:SyntaxExample} where the @ introduces an image name and the \$ a region name:

\lstset{style=pseudostyle,emph={@,\$}, emphstyle=\color{codegreen}}
\renewcommand{\lstlistingname}{Example}
\begin{lstlisting}[language=Pseudo,caption={Example for possible syntax},label={lst:SyntaxExample}]
Click 20px to the left and 10px down 
@"OK button" inside $"Dialog Window"
\end{lstlisting}

\subsection{XML based Test Specification Format}
This format is only intended for the initial development.
It does not include advanced features like snapshots or region support.
Simplicity and ease of implementation are favoured over expressiveness.
The basic structure is described in a XML schema.

Tests can use reusable sequences.
Only a single parameter is allowed for each sequence.
A collection of interactions like clicking and entering text are represented as an XML element.
\todo{More details}

\section{Test Management}
Managing tests for different projects, operating systems and software versions allows for many possible ways to organize tests.
The project is used as the highest level.
It is the container of all tests, sequences and images.
The need for reusable libraries of common sequences and images is deemed to be too low.
If user feedback suggest sufficient demand, it may be added in the future.

Projects can have many flavours.
A flavour holds a tree of tests.
Each inner node is named and all leaves are tests.
This mirrors a typical folder structure.
Flavours can be tagged.

There is only the generic concept of flavours to differentiate across version numbers and versions for different operating systems.
This is done because there is the use case where it makes sense to have the version number below the operating systems flavours, when for example they use different release cycles.
The inverse may also be sensible if one product should be tested across different operating systems.
Neither approach seem superior.
In the future there may be a way for the user to define aspects like \enquote{operating system} or \enquote{back end}. Then the structure will be revisited.

Each image, sequence and test can have many versions.
Each version other than the first has a predecessor version.
The versions build a tree based on this relationship.
Images, sequences and tests can be tagged.

Which image, sequence or test version to use is specified at the flavour level.
If a new version is created all flavours containing the direct predecessor get notified.

\section{First Version}
\subsection{Architecture}
One of Sikuliator's goals is to create tests without having to install software on many machines.
Therefore a web interface will be created in the future.
It will be provided by the so called master node.
The master provides a web API (not necessarily RESTful) which will be used by the web interface.
All tests and their executions are managed by the master node.

Clients, running inside VMs, connect to the master node and ask for work.
A pull based approach is used.
If no work is available the client goes into a sleep mode and must be awaken by the master.
To keep the deployment small, no message oriented middleware is used but communication happens over HTTP.

In the future this constellation will be extended by a system provider which can spin up VMs on demand.

All non-binary data is stored inside a relational database.
The binary data, consisting of images and executables, is stored inside an object storage system.
The object storage system must provide http based access because the images are needed for the web interface.

\subsection{Client}
The client uses SikuliX's API.
The API is Java based therefore a language running on the JVM is necessary.
Scala is used because the developer knows it better than Java.

The client is modelled as a finite state machine.
\todo{FSM graphic}

For the implementation the Play Framwork\cite{Play}, Akka\cite{Akka} and AkkaFSM\cite{AkkaFSM} are used.
They all are part of the \emph{Typesafe Reactive Platform}\cite{TypesafeRP}
%https://www.typesafe.com/products/typesafe-reactive-platform

\subsection{Server}
\todo{API}
\todo{Swagger}
%https://openapis.org/

% maybe in the future:
%http://jsonapi.org/

\subsection{Database}
\VMC{} uses PostgreSQL~\cite{PostgreSQL}.
Due to the familiarity, it will be used for Sikuliator, too.
Compatibility to other systems like MariaDB~\cite{MariaDB} was not regarded in this release.

\subsection{Object Storage System}
Several object storage systems were considered: OpenStack~Swift\cite{OpenStackSwift}, Riak~S2\cite{RiakS2} and 
MongoDB's\cite{MongoDB} GridFS\cite{GridFS} combined with RESTHeart\cite{RESTHeart}.
OpenStack~Swift and Riak~S2 need a lot of knowledge to configure and maintain.
Both usually run on a Linux cluster of at least three nodes.
MongoDB with RESTHeart can easily be installed on a single node.
Replication can be added as needed.

OpenStack~Swift may become more interesting in the future if some other part of OpenStack is used.
For example it could be used to create VMs, store VM images or provide identification.

\section{Future Roadmap}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printbibliography[notkeyword=software,resetnumbers=true,prefixnumbers=R]
\printbibliography[keyword=used,title={Used software},resetnumbers=true,prefixnumbers=US]
\printbibliography[notkeyword=used,keyword=software,title={Other software},resetnumbers=true,prefixnumbers=OS]

\end{document}


