%Dokumentation: http://texdoc.net/
\documentclass[a4paper,twocolumn]{article}
\usepackage[a4paper]{geometry}

\usepackage[british]{babel}        
\usepackage[utf8]{inputenc}        % for umlauts and other non 7bit ascii things
\usepackage[T1]{fontenc}           % this is needed for correct output of umlauts in pdf
\usepackage{lmodern}               % use a vector based font, not a bitmap based font for T1
\usepackage[stretch=10]{microtype} % improves font placements
%\usepackage{graphicx}
\usepackage[breaklinks, colorlinks,draft=false
%, citecolor=black, filecolor=black, linkcolor=black, urlcolor=black ,pdfborder=0
]{hyperref}

\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[autostyle=true,german=quotes]{csquotes}

\usepackage{graphicx}
%\usepackage{epstopdf}
%for plots: http://pgfplots.sourceforge.net/
%\usepackage[final]{pdfpages}

\usepackage{float}
\usepackage{rotating}

\usepackage[backend=biber,style=numeric]{biblatex}
\addbibresource{../bib/Sikuliator.bib}

\usepackage{todonotes}

\usepackage{placeins}

%\usepackage{chngcntr}
%\counterwithout{figure}{chapter}
%\counterwithout{table}{chapter}

%\usepackage{MnSymbol}
%\usepackage{listings}
%\lstset{tabsize=1,showtabs=false,extendedchars
%=false,escapebegin=\begin{text},escapeend=\end{text},literate=%
%    {Ö}{{\"O}}1
%    {Ä}{{\"A}}1
%    {Ü}{{\"U}}1
%    {ß}{{\ss}}1
%    {ü}{{\"u}}1
%    {ä}{{\"a}}1
%    {ö}{{\"o}}1
%    {~}{{\textasciitilde}}1,
%    %breakatwhitespace=true,
%    breaklines=true,
%    prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rhookswarrow}},
%    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rcurvearrowse}},
%    keepspaces=true,
%    }

%\usepackage{bigints}

\usepackage{enumitem}
\setlist{noitemsep}
%\theoremstyle{definition}
%\newtheorem{lemma}{Lemma}
%\newtheorem{definition}{Definition}
%\newtheorem*{note}{Bemerkung}
%\binoppenalty=\maxdimen
%\relpenalty=\maxdimen

\let\URL\url
\makeatletter
\def\url#1{\@URL#1;;\@nil}
\def\@URL#1;#2;#3\@nil{%
  \URL{#1}\ifx\relax#2\relax\else; \URL{#2}\fi}
\makeatother

\title{Sikuliator}
\author{Malte Schledjewski}
%\renewcommand{\baselinestretch}{1.1}
\linespread{1.1}

\hyphenation{Sikuliator OpenStack RESTHeart MongoDB SikuliX OpenCV Akka AkkaFSM PostgreSQL}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

%\setlength{\belowcaptionskip}{10pt}
%\setlength{\textfloatsep}{20.0pt plus 2.0pt minus 4.0pt}
%\setlength{\intextsep}{12.0pt plus 2.0pt minus 0.0pt}
%\setlength{\abovecaptionskip}{5pt}
%\setlength{\floatsep}{20.0pt plus 2.0pt minus 10.0pt}

\usepackage{parskip}
%\usepackage[compact]{titlesec}
\usepackage{emptypage}
\AtBeginDocument{\addtocontents{toc}{\protect\thispagestyle{empty}}} 


\newcommand{\VMC}[0]{VMC®}
\newcommand{\Sik}[0]{Sikuliator}

\newcommand{\notImplemented}[0]{\item[$\times$] }
\newcommand{\partiallyImplemented}[0]{\item[$\boxdot$] }
%\newcommand{\implemented}[0]{\item[$\blacksquare$] }
\newcommand{\implemented}[0]{\item[\checkmark] }

\begin{document}

%\pagestyle{headings}
%\pagestyle{myheadings}
%\markright{Malte Schledjewski\hfill Sikuliator\hfill}

%\setlength{\parskip}{2pt plus 0pt minus 0pt}

%\setlength{\parindent}{0cm}
\maketitle
\begin{abstract}
	
	
	This paper describes the development of \Sik{}, 
	a free system for automated GUI testing distributed across many machines.
	
\end{abstract}
\listoftodos

\tableofcontents

\section{Context}

The first version of \Sik{} is designed to suit the 
\enquote{\VMC{} - Virtual Measurement Campaign} developer team's needs in the
department \enquote{Mathematical Methods in Dynamics and Durability} 
at the Fraunhofer Institute for Industrial Mathematics ITWM.
\VMC{} is an application based on clients and a central database.
The clients are written in C++ and use the Qt Framework.
For some part of the client an embedded browser based on Qt WebEngine is used.

GUI testing \VMC{} is a time consuming task for the team.
Tests are managed by TestLink~\cite{TestLink} but have to be executed manually inside virtual machines.
This is time consuming especially because \VMC{} has many computations which last minutes or hours 
leaving the tester sitting idle while testing.
Due to the constrained resources thorough testing is often done just prior to a release
which causes regressions to be spotted late in the development cycle and potentially delaying the release. 

The team could use for example the Qt~Test~framework\cite{QtTest} which enables simulating mouse and keyboard input for the Qt framework to automate at least some parts of the test.
%Qt Test Overview - http://doc.qt.io/qt-5/qtest-overview.html
It does allow for checks based on the internal structure but not for visual appearance.

For web interfaces there exist frameworks like Selenium\cite{Selenium} to automatically distribute GUI test execution across many browsers.
These frameworks use the DOM and not the visual appearance.

Testing a hybrid application like \VMC{}, consisting of some parts written in C++ and some running in an embedded browser, is not covered by any freely available tool the team could find.

A bachelor thesis\cite{BachelorMapViewer}, which is based on a part of \VMC{}, mentions SikuliX\cite{SikuliX}.
SikuliX is a framework for GUI testing and automation.
It uses a matching operation from OpenCV\cite{OpenCV} to search for elements based on reference images.
SikuliX also simulates keyboard and mouse input.
The bachelor thesis mentions the idea to use the provided Python API in combination with a unit testing framework.
After some more discussions it was decided that this would require too much knowledge of Python to write tests.

\section{Goals}
The overarching goal of this project is to build Sikuliator, a system to distribute automatic GUI tests across many machines.
Instead of using Python to specify tests a new format will be developed.


The following goals were chosen in accordance with the \VMC{} development team.
Not all of them will be included in the first version.
\begin{enumerate}
	\item A free system under a free license shall be build.
	\item GUI tests are automatically executed without manual intervention.
	\item Tests may be executed in parallel across many machines.
	\item Tests must be reproducible.
	\item Simple tests must be easy to define without much programming knowledge.
	\item The success of a test execution may be rated automatically or manually by inspecting a created screenshot.
	\item Results are aggregated and statistics, trends and reports created.
	\item No client needs to be installed to create tests.
\end{enumerate}


%A tool which could execute a given sequence of steps and let the tester decide the correctness afterwards would increase the testers throughput.

The main challenges are believed to be:
\begin{enumerate}
	\item Creating the description format to be easy but powerful enough.
	\item Managing tests for different versions of the software.
	\item Ensuring reproducibility while not wasting too much time and too many resources.
	\item Handling external state like the database used in \VMC{}.
\end{enumerate}


\section{Ideas and Features}
\paragraph{Legend}
\begin{itemize}
	\implemented implemented in the first version
	\partiallyImplemented partially implemented in the first version
	\notImplemented not implemented in the first version
\end{itemize}
	
	In the following VM stands for virtual machine.
\begin{itemize}
	\implemented GUI tests are automatically executed.
	\implemented Test can be executed in parallel across many machines.
	\partiallyImplemented The success of a test execution can be
	\begin{itemize}
		\implemented rated automatically,
		\notImplemented manually by comparing created screenshots to reference images.
	\end{itemize}
	\implemented No client needed to manage the tests.
	\implemented Test results are aggregated.
	\partiallyImplemented Statistics are gathered.
	\begin{itemize}
		\implemented Track execution time.
	\end{itemize}
	\notImplemented Reports can be generated as PDFs.
	\notImplemented Notify about major changes in execution time.
	\implemented Run tests inside VMs to have a controlled environment.
	\notImplemented Use VM snapshots to remove redundant execution of common test beginnings.
	\notImplemented Authentication and authorization.
	\partiallyImplemented Web interface
	\notImplemented Keep an audible log.
	\notImplemented Collect coverage data and select relevant tests to execute based on change set.
	\notImplemented Use SikuliX's region support instead of searching across the whole screen.
	\notImplemented Use a monitoring system to check for crashed clients.
	\notImplemented Dynamically spin up VM instances as needed.
	\notImplemented Have an interactive mode for test creation where one client directly executes steps.
	\notImplemented Integrate \Sik{} into the Jenkins\cite{Jenkins} pipeline as a step after building the software.
\end{itemize}

\Sik{}'s first version is developed as a graded project by Malte Schledjewski.
Due to this the scope is limited.
Some parts like snapshots do not have a high priority because \VMC{} has external state in the database which is not captured. Also no coverage data is gathered so instrumenting the build would cost too much time. 
SikuliX's region support increases the complexity of describing tests and will therefore only be integrated in a later version.


%\section{System Overview}
%The new system will not be software that has to be installed but accessed through a web interface.
%This reduces the effort needed for installing and upgrading the system and does not have to include the internal IT team.
%This web interface will be supplied by an master node which also manages test execution.
%Currently virtual machines which reset to a specified snapshot on reboot are used for testing.
%A test client including SikuliX will be installed and integrated into a new snapshot.
%This client connects to the master node to ask for work.
%No messaging broker is used but communication happens over simple HTTP to keep the system administration simple.
%
%The virtual machines are managed by a system broker.
%It knows how to reset machines to a clean state and may do health checking.
%In the future there may be back ends based on VirtualBox\cite{VirtualBox}, OpenStack\cite{OpenStack} or the alike to dynamically spin up instances when needed.
%
%Test specifications and other related information will be stored in a relational database.
%
%SikuliX is based on searching for reference images, therefore a lot of binary files have to be stored.
%They must also be accessible over HTTP for integration into the web interface.
%One idea was to use an object storage system like OpenStack~Swift\cite{OpenStackSwift} or Riak~S2\cite{RiakS2}.
%These systems need a lot of knowledge to configure and maintain.
%Support for them will maybe be added in the future.
%In the meantime a solution based on MongoDB's GridFS\cite{GridFS} and RESTHeart\cite{RESTHeart} is chosen.
%It provides rather simple set up contained on one machine.
%
%The test executables are also stored in RESTHeart so that no additional subsystem has to be integrated.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% add system overview graphic here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsection{Technology Decisions}
%
%MongoDB's GridFS and RESTHeart are a complete subsystem.
%The relational database is realised by PostgreSQL\cite{PostgreSQL} because it is already used for \VMC{}.
%SikuliX provides an Java API therefore a language that runs on the JVM is needed for the client.
%Scala is chosen over Java because it is better known by the author.
%Also does integrate well into using Akka\cite{Akka}, AkkaFSM\cite{AkkaFSM} and Play\cite{Play}.
%The client is modelled as an finite state machine based on AkkaFSM.
%To keep the client, the system broker and the master node coherent Scala, Akka and Play is used across all of them.


\section{Test Specification}
There were two ideas for specifying tests: either use a structured text format like XML, JSON, YAML and the like or create a domain specific language (DSL).
Creating a DSL seemed to complex and time consuming for the first version.
Therefore a simple format based on XML is defined.

The future DSL will integrate snapshots and region support.
This needs careful language design.
Tools like JetBrains' Meta Programming System\cite{MPS}
%https://www.jetbrains.com/mps/
or Eclipse Xtext\cite{Xtext} will probably be used to get some tooling like syntax completion.
%https://eclipse.org/Xtext/
It will probably mirror natural language more closely.
% Click 20px to the left and 10px down @"OK button" inside $"Dialog Window"

\subsection{XML based Test Specification Format}
This format is only intended for the initial development.
It does not include advanced features like snapshots or region support.
Simplicity and ease of implementation are favoured over expressiveness.
The basic structure is described in a XML schema.

Tests can use reusable sequences.
Only a single parameter is allowed for each sequence.
A collection of interactions like clicking and entering text are represented as an XML element.


\section{Test Management}
Managing tests for different projects, operating systems and software versions allows for many possible ways to organize tests.
The project is used as the highest level.
It is the container of all tests, sequences and images.
The need for reusable libraries of common sequences and images is deemed to be too low.
If user feedback suggest sufficient demand it may be added in the future.

Project flavours are beneath the project.
A flavour holds a tree of tests.
Each inner node is named and all leaves are tests.
This mirrors a typical folder structure.
Flavours can be tagged.

There is only the generic concept of flavours to differentiate across version numbers and versions for different operating systems.
This is done because there is the use case where it makes sense to have the version number below the operating systems flavours, when for example they use different release cycles.
The inverse may also be sensible if one product should be tested across different operating systems.
Neither approach seem superior.
In the future there may be a way for the user to define aspects like \enquote{operating system} or \enquote{back end}. Then the structure will be revisited.

Each image, sequence and test can have many versions.
Each version other than the first has a predecessor version.
The versions build a tree based on this relationship.
Images, sequences and tests can be tagged.

Which image, sequence or test version to use is specified at the flavour level.
If a new version is created all flavours containing the direct predecessor get notified.

\section{First Version}

\subsection{Limited Scope}

\subsection{Architecture}

\subsection{Server}

\subsection{Client}


\printbibliography[notkeyword=software]
\printbibliography[keyword=used,title={Used software}]
\printbibliography[notkeyword=used,keyword=software,title={Other software}]

\end{document}


